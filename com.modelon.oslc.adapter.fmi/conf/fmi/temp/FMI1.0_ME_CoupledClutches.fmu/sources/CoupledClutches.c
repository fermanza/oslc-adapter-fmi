/* Main Simulation File */
/* Simulation code for CoupledClutches generated by the OpenModelica Compiler 1.9.2+dev (r24999). */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_xml.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <assert.h>
#include <string.h>

#include "CoupledClutches_functions.h"
#include "CoupledClutches_model.h"
#include "CoupledClutches_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif

#define threadData data->threadData


#define prefixedName_performSimulation CoupledClutches_performSimulation
#include <simulation/solver/perform_simulation.c>

#define prefixedName_performQSSSimulation CoupledClutches_performQSSSimulation
#include <simulation/solver/perform_qss_simulation.c>

/* dummy VARINFO and FILEINFO */
const FILE_INFO dummyFILE_INFO = omc_dummyFileInfo;
const VAR_INFO dummyVAR_INFO = omc_dummyVarInfo;
#if defined(__cplusplus)
extern "C" {
#endif
int measure_time_flag = 0;

int CoupledClutches_input_function(DATA *data)
{
  TRACE_PUSH

  $Pstep2 = data->simulationInfo.inputVars[0];
  
  TRACE_POP
  return 0;
}

int CoupledClutches_input_function_init(DATA *data)
{
  TRACE_PUSH

  $P$ATTRIBUTE$Pstep2.start = data->simulationInfo.inputVars[0];
  
  TRACE_POP
  return 0;
}


int CoupledClutches_output_function(DATA *data)
{
  TRACE_PUSH

  data->simulationInfo.outputVars[0] = $PJ1_w1;
  data->simulationInfo.outputVars[1] = $PJ2_w1;
  data->simulationInfo.outputVars[2] = $PJ3_w1;
  data->simulationInfo.outputVars[3] = $PJ4_w1;
  
  TRACE_POP
  return 0;
}


/*
 equation index: 83
 type: SIMPLE_ASSIGN
 clutch2._f_normalized = step1.offset + (if time < step1.startTime then 0.0 else step1.height)
 */
void CoupledClutches_eqFunction_83(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,83};
  modelica_boolean tmp122;
  RELATIONHYSTERESIS(tmp122, time, $Pstep1$PstartTime, 4, Less);
  $Pclutch2$Pf_normalized = ($Pstep1$Poffset + (tmp122?0.0:$Pstep1$Pheight));
  TRACE_POP
}
/*
 equation index: 84
 type: SIMPLE_ASSIGN
 clutch2._fn = clutch2.fn_max * clutch2.f_normalized
 */
void CoupledClutches_eqFunction_84(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,84};
  $Pclutch2$Pfn = ($Pclutch2$Pfn_max * $Pclutch2$Pf_normalized);
  TRACE_POP
}
/*
 equation index: 85
 type: SIMPLE_ASSIGN
 clutch2._tau0 = clutch2.mue0 * clutch2.cgeo * clutch2.fn
 */
void CoupledClutches_eqFunction_85(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,85};
  $Pclutch2$Ptau0 = ($Pclutch2$Pmue0 * ($Pclutch2$Pcgeo * $Pclutch2$Pfn));
  TRACE_POP
}
/*
 equation index: 86
 type: SIMPLE_ASSIGN
 clutch2._tau0_max = clutch2.peak * clutch2.tau0
 */
void CoupledClutches_eqFunction_86(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,86};
  $Pclutch2$Ptau0_max = ($Pclutch2$Ppeak * $Pclutch2$Ptau0);
  TRACE_POP
}
/*
 equation index: 87
 type: SIMPLE_ASSIGN
 clutch2._free = clutch2.fn <= 0.0
 */
void CoupledClutches_eqFunction_87(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,87};
  modelica_boolean tmp123;
  RELATIONHYSTERESIS(tmp123, $Pclutch2$Pfn, 0.0, 5, LessEq);
  $Pclutch2$Pfree = tmp123;
  TRACE_POP
}
/*
 equation index: 88
 type: SIMPLE_ASSIGN
 clutch1._f_normalized = sin2.offset + (if time < sin2.startTime then 0.0 else sin2.amplitude * sin(6.283185307179586 * sin2.freqHz * (time - sin2.startTime) + sin2.phase))
 */
void CoupledClutches_eqFunction_88(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,88};
  modelica_boolean tmp124;
  RELATIONHYSTERESIS(tmp124, time, $Psin2$PstartTime, 2, Less);
  $Pclutch1$Pf_normalized = ($Psin2$Poffset + (tmp124?0.0:($Psin2$Pamplitude * sin(((6.283185307179586 * ($Psin2$PfreqHz * (time - $Psin2$PstartTime))) + $Psin2$Pphase)))));
  TRACE_POP
}
/*
 equation index: 89
 type: SIMPLE_ASSIGN
 clutch1._fn = clutch1.fn_max * clutch1.f_normalized
 */
void CoupledClutches_eqFunction_89(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,89};
  $Pclutch1$Pfn = ($Pclutch1$Pfn_max * $Pclutch1$Pf_normalized);
  TRACE_POP
}
/*
 equation index: 90
 type: SIMPLE_ASSIGN
 clutch1._tau0 = clutch1.mue0 * clutch1.cgeo * clutch1.fn
 */
void CoupledClutches_eqFunction_90(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,90};
  $Pclutch1$Ptau0 = ($Pclutch1$Pmue0 * ($Pclutch1$Pcgeo * $Pclutch1$Pfn));
  TRACE_POP
}
/*
 equation index: 91
 type: SIMPLE_ASSIGN
 clutch1._tau0_max = clutch1.peak * clutch1.tau0
 */
void CoupledClutches_eqFunction_91(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,91};
  $Pclutch1$Ptau0_max = ($Pclutch1$Ppeak * $Pclutch1$Ptau0);
  TRACE_POP
}
/*
 equation index: 92
 type: SIMPLE_ASSIGN
 clutch1._free = clutch1.fn <= 0.0
 */
void CoupledClutches_eqFunction_92(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,92};
  modelica_boolean tmp125;
  RELATIONHYSTERESIS(tmp125, $Pclutch1$Pfn, 0.0, 3, LessEq);
  $Pclutch1$Pfree = tmp125;
  TRACE_POP
}
/*
 equation index: 93
 type: SIMPLE_ASSIGN
 der(clutch3._phi_rel) = clutch3.w_rel
 */
void CoupledClutches_eqFunction_93(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,93};
  $P$DER$Pclutch3$Pphi_rel = $Pclutch3$Pw_rel;
  TRACE_POP
}
/*
 equation index: 94
 type: SIMPLE_ASSIGN
 clutch3._fn = clutch3.fn_max * step2
 */
void CoupledClutches_eqFunction_94(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,94};
  $Pclutch3$Pfn = ($Pclutch3$Pfn_max * $Pstep2);
  TRACE_POP
}
/*
 equation index: 95
 type: SIMPLE_ASSIGN
 clutch3._free = clutch3.fn <= 0.0
 */
void CoupledClutches_eqFunction_95(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,95};
  modelica_boolean tmp126;
  RELATIONHYSTERESIS(tmp126, $Pclutch3$Pfn, 0.0, 1, LessEq);
  $Pclutch3$Pfree = tmp126;
  TRACE_POP
}
/*
 equation index: 96
 type: SIMPLE_ASSIGN
 clutch3._tau0 = clutch3.mue0 * clutch3.cgeo * clutch3.fn
 */
void CoupledClutches_eqFunction_96(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,96};
  $Pclutch3$Ptau0 = ($Pclutch3$Pmue0 * ($Pclutch3$Pcgeo * $Pclutch3$Pfn));
  TRACE_POP
}
/*
 equation index: 97
 type: SIMPLE_ASSIGN
 clutch3._tau0_max = clutch3.peak * clutch3.tau0
 */
void CoupledClutches_eqFunction_97(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,97};
  $Pclutch3$Ptau0_max = ($Pclutch3$Ppeak * $Pclutch3$Ptau0);
  TRACE_POP
}
/*
 equation index: 98
 type: SIMPLE_ASSIGN
 der(J3._phi) = J3.w
 */
void CoupledClutches_eqFunction_98(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,98};
  $P$DER$PJ3$Pphi = $PJ3$Pw;
  TRACE_POP
}
/*
 equation index: 99
 type: SIMPLE_ASSIGN
 der(clutch2._phi_rel) = clutch2.w_rel
 */
void CoupledClutches_eqFunction_99(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,99};
  $P$DER$Pclutch2$Pphi_rel = $Pclutch2$Pw_rel;
  TRACE_POP
}
/*
 equation index: 100
 type: SIMPLE_ASSIGN
 sin1._y = sin1.offset + (if time < sin1.startTime then 0.0 else sin1.amplitude * sin(6.283185307179586 * sin1.freqHz * (time - sin1.startTime) + sin1.phase))
 */
void CoupledClutches_eqFunction_100(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,100};
  modelica_boolean tmp127;
  RELATIONHYSTERESIS(tmp127, time, $Psin1$PstartTime, 0, Less);
  $Psin1$Py = ($Psin1$Poffset + (tmp127?0.0:($Psin1$Pamplitude * sin(((6.283185307179586 * ($Psin1$PfreqHz * (time - $Psin1$PstartTime))) + $Psin1$Pphase)))));
  TRACE_POP
}
void CoupledClutches_eqFunction_101(DATA*);
void CoupledClutches_eqFunction_102(DATA*);
void CoupledClutches_eqFunction_103(DATA*);
void CoupledClutches_eqFunction_104(DATA*);
void CoupledClutches_eqFunction_105(DATA*);
void CoupledClutches_eqFunction_106(DATA*);
void CoupledClutches_eqFunction_107(DATA*);
void CoupledClutches_eqFunction_108(DATA*);
void CoupledClutches_eqFunction_109(DATA*);
void CoupledClutches_eqFunction_110(DATA*);
void CoupledClutches_eqFunction_111(DATA*);
void CoupledClutches_eqFunction_112(DATA*);
void CoupledClutches_eqFunction_113(DATA*);
void CoupledClutches_eqFunction_114(DATA*);
void CoupledClutches_eqFunction_115(DATA*);
void CoupledClutches_eqFunction_116(DATA*);
void CoupledClutches_eqFunction_117(DATA*);
void CoupledClutches_eqFunction_118(DATA*);
void CoupledClutches_eqFunction_119(DATA*);
void CoupledClutches_eqFunction_122(DATA*);
void CoupledClutches_eqFunction_121(DATA*);
void CoupledClutches_eqFunction_120(DATA*);
/*
 equation index: 123
 indexNonlinear: 1
 type: NONLINEAR
 
 vars: {clutch3._sa, clutch2._sa, clutch1._sa}
 eqns: {101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 122, 121, 120}
 */
void CoupledClutches_eqFunction_123(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,123};
  int retValue;
  /* extrapolate data */
  data->simulationInfo.nonlinearSystemData[1].nlsx[0] = $Pclutch3$Psa;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[0] = _$Pclutch3$Psa(1) /*old1*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[0] = extraPolate(data, _$Pclutch3$Psa(1) /*old1*/, _$Pclutch3$Psa(2) /*old2*/,$P$ATTRIBUTE$Pclutch3$Psa.min, $P$ATTRIBUTE$Pclutch3$Psa.max);
  data->simulationInfo.nonlinearSystemData[1].nlsx[1] = $Pclutch2$Psa;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[1] = _$Pclutch2$Psa(1) /*old1*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[1] = extraPolate(data, _$Pclutch2$Psa(1) /*old1*/, _$Pclutch2$Psa(2) /*old2*/,$P$ATTRIBUTE$Pclutch2$Psa.min, $P$ATTRIBUTE$Pclutch2$Psa.max);
  data->simulationInfo.nonlinearSystemData[1].nlsx[2] = $Pclutch1$Psa;
  data->simulationInfo.nonlinearSystemData[1].nlsxOld[2] = _$Pclutch1$Psa(1) /*old1*/;
  data->simulationInfo.nonlinearSystemData[1].nlsxExtrapolation[2] = extraPolate(data, _$Pclutch1$Psa(1) /*old1*/, _$Pclutch1$Psa(2) /*old2*/,$P$ATTRIBUTE$Pclutch1$Psa.min, $P$ATTRIBUTE$Pclutch1$Psa.max);
  retValue = solve_nonlinear_system(data, 1);
  /* check if solution process was sucessful */
  if (retValue > 0){
    const int indexes[2] = {1,123};
    throwStreamPrintWithEquationIndexes(threadData, indexes, "Solving non-linear system 123 failed at time=%.15g.\nFor more information please use -lv LOG_NLS.", time);
  }
  /* write solution */
  $Pclutch3$Psa = data->simulationInfo.nonlinearSystemData[1].nlsx[0];
  $Pclutch2$Psa = data->simulationInfo.nonlinearSystemData[1].nlsx[1];
  $Pclutch1$Psa = data->simulationInfo.nonlinearSystemData[1].nlsx[2];
  TRACE_POP
}
/*
 equation index: 124
 type: SIMPLE_ASSIGN
 der(clutch1._w_rel) = clutch1.a_relfric
 */
void CoupledClutches_eqFunction_124(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,124};
  $P$DER$Pclutch1$Pw_rel = $Pclutch1$Pa_relfric;
  TRACE_POP
}
/*
 equation index: 125
 type: SIMPLE_ASSIGN
 clutch1._mode = if clutch1.free then 2 else if (pre(clutch1.mode) == 1 or pre(clutch1.mode) == 2 or clutch1.startForward) and clutch1.w_rel > 0.0 then 1 else if (pre(clutch1.mode) == -1 or pre(clutch1.mode) == 2 or clutch1.startBackward) and clutch1.w_rel < 0.0 then -1 else 0
 */
void CoupledClutches_eqFunction_125(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,125};
  modelica_boolean tmp205;
  modelica_boolean tmp208;
  modelica_boolean tmp209;
  modelica_integer tmp210;
  modelica_boolean tmp211;
  modelica_integer tmp212;
  tmp211 = (modelica_boolean)$Pclutch1$Pfree;
  if(tmp211)
  {
    tmp212 = (modelica_integer) 2;
  }
  else
  {
    RELATIONHYSTERESIS(tmp205, $Pclutch1$Pw_rel, 0.0, 13, Greater);
    tmp209 = (modelica_boolean)(((($P$PRE$Pclutch1$Pmode == (modelica_integer) 1) || ($P$PRE$Pclutch1$Pmode == (modelica_integer) 2)) || $Pclutch1$PstartForward) && tmp205);
    if(tmp209)
    {
      tmp210 = (modelica_integer) 1;
    }
    else
    {
      RELATIONHYSTERESIS(tmp208, $Pclutch1$Pw_rel, 0.0, 17, Less);
      tmp210 = ((((($P$PRE$Pclutch1$Pmode == (modelica_integer) -1) || ($P$PRE$Pclutch1$Pmode == (modelica_integer) 2)) || $Pclutch1$PstartBackward) && tmp208)?(modelica_integer) -1:(modelica_integer) 0);
    }
    tmp212 = tmp210;
  }
  $Pclutch1$Pmode = tmp212;
  TRACE_POP
}
/*
 equation index: 126
 type: SIMPLE_ASSIGN
 der(clutch2._w_rel) = clutch2.a_relfric
 */
void CoupledClutches_eqFunction_126(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,126};
  $P$DER$Pclutch2$Pw_rel = $Pclutch2$Pa_relfric;
  TRACE_POP
}
/*
 equation index: 127
 type: SIMPLE_ASSIGN
 clutch2._mode = if clutch2.free then 2 else if (pre(clutch2.mode) == 1 or pre(clutch2.mode) == 2 or clutch2.startForward) and clutch2.w_rel > 0.0 then 1 else if (pre(clutch2.mode) == -1 or pre(clutch2.mode) == 2 or clutch2.startBackward) and clutch2.w_rel < 0.0 then -1 else 0
 */
void CoupledClutches_eqFunction_127(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,127};
  modelica_boolean tmp215;
  modelica_boolean tmp218;
  modelica_boolean tmp219;
  modelica_integer tmp220;
  modelica_boolean tmp221;
  modelica_integer tmp222;
  tmp221 = (modelica_boolean)$Pclutch2$Pfree;
  if(tmp221)
  {
    tmp222 = (modelica_integer) 2;
  }
  else
  {
    RELATIONHYSTERESIS(tmp215, $Pclutch2$Pw_rel, 0.0, 9, Greater);
    tmp219 = (modelica_boolean)(((($P$PRE$Pclutch2$Pmode == (modelica_integer) 1) || ($P$PRE$Pclutch2$Pmode == (modelica_integer) 2)) || $Pclutch2$PstartForward) && tmp215);
    if(tmp219)
    {
      tmp220 = (modelica_integer) 1;
    }
    else
    {
      RELATIONHYSTERESIS(tmp218, $Pclutch2$Pw_rel, 0.0, 29, Less);
      tmp220 = ((((($P$PRE$Pclutch2$Pmode == (modelica_integer) -1) || ($P$PRE$Pclutch2$Pmode == (modelica_integer) 2)) || $Pclutch2$PstartBackward) && tmp218)?(modelica_integer) -1:(modelica_integer) 0);
    }
    tmp222 = tmp220;
  }
  $Pclutch2$Pmode = tmp222;
  TRACE_POP
}
/*
 equation index: 128
 type: SIMPLE_ASSIGN
 clutch2._lossPower = clutch2.tau * clutch2.w_rel
 */
void CoupledClutches_eqFunction_128(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,128};
  $Pclutch2$PlossPower = ($Pclutch2$Ptau * $Pclutch2$Pw_rel);
  TRACE_POP
}
/*
 equation index: 129
 type: SIMPLE_ASSIGN
 clutch3._lossPower = clutch3.tau * clutch3.w_rel
 */
void CoupledClutches_eqFunction_129(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,129};
  $Pclutch3$PlossPower = ($Pclutch3$Ptau * $Pclutch3$Pw_rel);
  TRACE_POP
}
/*
 equation index: 130
 type: SIMPLE_ASSIGN
 clutch3._mode = if clutch3.free then 2 else if (pre(clutch3.mode) == 1 or pre(clutch3.mode) == 2 or clutch3.startForward) and clutch3.w_rel > 0.0 then 1 else if (pre(clutch3.mode) == -1 or pre(clutch3.mode) == 2 or clutch3.startBackward) and clutch3.w_rel < 0.0 then -1 else 0
 */
void CoupledClutches_eqFunction_130(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,130};
  modelica_boolean tmp225;
  modelica_boolean tmp228;
  modelica_boolean tmp229;
  modelica_integer tmp230;
  modelica_boolean tmp231;
  modelica_integer tmp232;
  tmp231 = (modelica_boolean)$Pclutch3$Pfree;
  if(tmp231)
  {
    tmp232 = (modelica_integer) 2;
  }
  else
  {
    RELATIONHYSTERESIS(tmp225, $Pclutch3$Pw_rel, 0.0, 21, Greater);
    tmp229 = (modelica_boolean)(((($P$PRE$Pclutch3$Pmode == (modelica_integer) 1) || ($P$PRE$Pclutch3$Pmode == (modelica_integer) 2)) || $Pclutch3$PstartForward) && tmp225);
    if(tmp229)
    {
      tmp230 = (modelica_integer) 1;
    }
    else
    {
      RELATIONHYSTERESIS(tmp228, $Pclutch3$Pw_rel, 0.0, 25, Less);
      tmp230 = ((((($P$PRE$Pclutch3$Pmode == (modelica_integer) -1) || ($P$PRE$Pclutch3$Pmode == (modelica_integer) 2)) || $Pclutch3$PstartBackward) && tmp228)?(modelica_integer) -1:(modelica_integer) 0);
    }
    tmp232 = tmp230;
  }
  $Pclutch3$Pmode = tmp232;
  TRACE_POP
}
/*
 equation index: 131
 type: SIMPLE_ASSIGN
 der(clutch3._w_rel) = clutch3.a_relfric
 */
void CoupledClutches_eqFunction_131(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,131};
  $P$DER$Pclutch3$Pw_rel = $Pclutch3$Pa_relfric;
  TRACE_POP
}
/*
 equation index: 132
 type: SIMPLE_ASSIGN
 der(J3._w) = J3.a
 */
void CoupledClutches_eqFunction_132(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,132};
  $P$DER$PJ3$Pw = $PJ3$Pa;
  TRACE_POP
}
/*
 equation index: 133
 type: SIMPLE_ASSIGN
 clutch1._lossPower = clutch1.tau * clutch1.w_rel
 */
void CoupledClutches_eqFunction_133(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,133};
  $Pclutch1$PlossPower = ($Pclutch1$Ptau * $Pclutch1$Pw_rel);
  TRACE_POP
}
/*
 equation index: 134
 type: SIMPLE_ASSIGN
 der(clutch1._phi_rel) = clutch1.w_rel
 */
void CoupledClutches_eqFunction_134(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,134};
  $P$DER$Pclutch1$Pphi_rel = $Pclutch1$Pw_rel;
  TRACE_POP
}
/*
 equation index: 135
 type: SIMPLE_ASSIGN
 J3_w1 = J3.w
 */
void CoupledClutches_eqFunction_135(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,135};
  $PJ3_w1 = $PJ3$Pw;
  TRACE_POP
}
/*
 equation index: 136
 type: SIMPLE_ASSIGN
 J2_w1 = J3.w - clutch2.w_rel
 */
void CoupledClutches_eqFunction_136(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,136};
  $PJ2_w1 = ($PJ3$Pw - $Pclutch2$Pw_rel);
  TRACE_POP
}
/*
 equation index: 137
 type: SIMPLE_ASSIGN
 J1_w1 = J2_w1 - clutch1.w_rel
 */
void CoupledClutches_eqFunction_137(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,137};
  $PJ1_w1 = ($PJ2_w1 - $Pclutch1$Pw_rel);
  TRACE_POP
}
/*
 equation index: 138
 type: SIMPLE_ASSIGN
 J4_w1 = clutch3.w_rel + J3.w
 */
void CoupledClutches_eqFunction_138(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,138};
  $PJ4_w1 = ($Pclutch3$Pw_rel + $PJ3$Pw);
  TRACE_POP
}
/*
 equation index: 139
 type: SIMPLE_ASSIGN
 J4._phi = clutch3.phi_rel + J3.phi
 */
void CoupledClutches_eqFunction_139(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,139};
  $PJ4$Pphi = ($Pclutch3$Pphi_rel + $PJ3$Pphi);
  TRACE_POP
}
/*
 equation index: 140
 type: SIMPLE_ASSIGN
 J2._phi = J3.phi - clutch2.phi_rel
 */
void CoupledClutches_eqFunction_140(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,140};
  $PJ2$Pphi = ($PJ3$Pphi - $Pclutch2$Pphi_rel);
  TRACE_POP
}
/*
 equation index: 141
 type: SIMPLE_ASSIGN
 J1._phi = J2.phi - clutch1.phi_rel
 */
void CoupledClutches_eqFunction_141(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,141};
  $PJ1$Pphi = ($PJ2$Pphi - $Pclutch1$Pphi_rel);
  TRACE_POP
}


int CoupledClutches_functionDAE(DATA *data)
{
  TRACE_PUSH
  int equationIndexes[1] = {0};
  
  data->simulationInfo.needToIterate = 0;
  data->simulationInfo.discreteCall = 1;
  CoupledClutches_eqFunction_83(data);

  CoupledClutches_eqFunction_84(data);

  CoupledClutches_eqFunction_85(data);

  CoupledClutches_eqFunction_86(data);

  CoupledClutches_eqFunction_87(data);

  CoupledClutches_eqFunction_88(data);

  CoupledClutches_eqFunction_89(data);

  CoupledClutches_eqFunction_90(data);

  CoupledClutches_eqFunction_91(data);

  CoupledClutches_eqFunction_92(data);

  CoupledClutches_eqFunction_93(data);

  CoupledClutches_eqFunction_94(data);

  CoupledClutches_eqFunction_95(data);

  CoupledClutches_eqFunction_96(data);

  CoupledClutches_eqFunction_97(data);

  CoupledClutches_eqFunction_98(data);

  CoupledClutches_eqFunction_99(data);

  CoupledClutches_eqFunction_100(data);

  CoupledClutches_eqFunction_123(data);

  CoupledClutches_eqFunction_124(data);

  CoupledClutches_eqFunction_125(data);

  CoupledClutches_eqFunction_126(data);

  CoupledClutches_eqFunction_127(data);

  CoupledClutches_eqFunction_128(data);

  CoupledClutches_eqFunction_129(data);

  CoupledClutches_eqFunction_130(data);

  CoupledClutches_eqFunction_131(data);

  CoupledClutches_eqFunction_132(data);

  CoupledClutches_eqFunction_133(data);

  CoupledClutches_eqFunction_134(data);

  CoupledClutches_eqFunction_135(data);

  CoupledClutches_eqFunction_136(data);

  CoupledClutches_eqFunction_137(data);

  CoupledClutches_eqFunction_138(data);

  CoupledClutches_eqFunction_139(data);

  CoupledClutches_eqFunction_140(data);

  CoupledClutches_eqFunction_141(data);
  
  TRACE_POP
  return 0;
}


/* forwarded equations */
extern void CoupledClutches_eqFunction_83(DATA* data);
extern void CoupledClutches_eqFunction_84(DATA* data);
extern void CoupledClutches_eqFunction_85(DATA* data);
extern void CoupledClutches_eqFunction_86(DATA* data);
extern void CoupledClutches_eqFunction_87(DATA* data);
extern void CoupledClutches_eqFunction_88(DATA* data);
extern void CoupledClutches_eqFunction_89(DATA* data);
extern void CoupledClutches_eqFunction_90(DATA* data);
extern void CoupledClutches_eqFunction_91(DATA* data);
extern void CoupledClutches_eqFunction_92(DATA* data);
extern void CoupledClutches_eqFunction_93(DATA* data);
extern void CoupledClutches_eqFunction_94(DATA* data);
extern void CoupledClutches_eqFunction_95(DATA* data);
extern void CoupledClutches_eqFunction_96(DATA* data);
extern void CoupledClutches_eqFunction_97(DATA* data);
extern void CoupledClutches_eqFunction_98(DATA* data);
extern void CoupledClutches_eqFunction_99(DATA* data);
extern void CoupledClutches_eqFunction_100(DATA* data);
extern void CoupledClutches_eqFunction_123(DATA* data);
extern void CoupledClutches_eqFunction_124(DATA* data);
extern void CoupledClutches_eqFunction_126(DATA* data);
extern void CoupledClutches_eqFunction_131(DATA* data);
extern void CoupledClutches_eqFunction_132(DATA* data);
extern void CoupledClutches_eqFunction_134(DATA* data);

static void functionODE_system0(DATA *data)
{
  CoupledClutches_eqFunction_83(data);

  CoupledClutches_eqFunction_84(data);

  CoupledClutches_eqFunction_85(data);

  CoupledClutches_eqFunction_86(data);

  CoupledClutches_eqFunction_87(data);

  CoupledClutches_eqFunction_88(data);

  CoupledClutches_eqFunction_89(data);

  CoupledClutches_eqFunction_90(data);

  CoupledClutches_eqFunction_91(data);

  CoupledClutches_eqFunction_92(data);

  CoupledClutches_eqFunction_93(data);

  CoupledClutches_eqFunction_94(data);

  CoupledClutches_eqFunction_95(data);

  CoupledClutches_eqFunction_96(data);

  CoupledClutches_eqFunction_97(data);

  CoupledClutches_eqFunction_98(data);

  CoupledClutches_eqFunction_99(data);

  CoupledClutches_eqFunction_100(data);

  CoupledClutches_eqFunction_123(data);

  CoupledClutches_eqFunction_124(data);

  CoupledClutches_eqFunction_126(data);

  CoupledClutches_eqFunction_131(data);

  CoupledClutches_eqFunction_132(data);

  CoupledClutches_eqFunction_134(data);
}

int CoupledClutches_functionODE(DATA *data)
{
  TRACE_PUSH

  
  data->simulationInfo.callStatistics.functionODE++;
  
  data->simulationInfo.discreteCall = 0;
  functionODE_system0(data);

  
  TRACE_POP
  return 0;
}

/* forward the main in the simulation runtime */
extern int _main_SimulationRuntime(int argc, char**argv, DATA *data);

#include "CoupledClutches_12jac.h"
#include "CoupledClutches_13opt.h"
extern void CoupledClutches_callExternalObjectConstructors(DATA *data);
extern void CoupledClutches_callExternalObjectDestructors(DATA *_data);
extern void CoupledClutches_initialNonLinearSystem(int nNonLinearSystems, NONLINEAR_SYSTEM_DATA *data);
extern void CoupledClutches_initialLinearSystem(int nLinearSystems, LINEAR_SYSTEM_DATA *data);
extern void CoupledClutches_initialMixedSystem(int nMixedSystems, MIXED_SYSTEM_DATA *data);
extern void CoupledClutches_initializeStateSets(int nStateSets, STATE_SET_DATA* statesetData, DATA *data);
extern int CoupledClutches_functionAlgebraics(DATA *data);
extern int CoupledClutches_function_storeDelayed(DATA *data);
extern int CoupledClutches_updateBoundVariableAttributes(DATA *data);
extern int CoupledClutches_functionInitialEquations(DATA *data);
extern int CoupledClutches_functionRemovedInitialEquations(DATA *data);
extern int CoupledClutches_updateBoundParameters(DATA *data);
extern int CoupledClutches_checkForAsserts(DATA *data);
extern int CoupledClutches_function_ZeroCrossingsEquations(DATA *data);
extern int CoupledClutches_function_ZeroCrossings(DATA *data, double* gout);
extern int CoupledClutches_function_updateRelations(DATA *data, int evalZeroCross);
extern int CoupledClutches_checkForDiscreteChanges(DATA *data);
extern const char* CoupledClutches_zeroCrossingDescription(int i, int **out_EquationIndexes);
extern const char* CoupledClutches_relationDescription(int i);
extern void CoupledClutches_function_initSample(DATA *data);
extern int CoupledClutches_initialAnalyticJacobianG(void* data);
extern int CoupledClutches_initialAnalyticJacobianA(void* data);
extern int CoupledClutches_initialAnalyticJacobianB(void* data);
extern int CoupledClutches_initialAnalyticJacobianC(void* data);
extern int CoupledClutches_initialAnalyticJacobianD(void* data);
extern int CoupledClutches_functionJacG_column(void* data);
extern int CoupledClutches_functionJacA_column(void* data);
extern int CoupledClutches_functionJacB_column(void* data);
extern int CoupledClutches_functionJacC_column(void* data);
extern int CoupledClutches_functionJacD_column(void* data);
extern const char* CoupledClutches_linear_model_frame(void);
extern int CoupledClutches_mayer(DATA* data, modelica_real** res, short *);
extern int CoupledClutches_lagrange(DATA* data, modelica_real** res, short *, short *);
extern int CoupledClutches_pickUpBoundsForInputsInOptimization(DATA* data, modelica_real* min, modelica_real* max, modelica_real*nominal, modelica_boolean *useNominal, char ** name, modelica_real * start, modelica_real * startTimeOpt);
extern int CoupledClutches_setInputData(DATA *data);
extern int CoupledClutches_getTimeGrid(DATA *data, modelica_integer * nsi, modelica_real**t);

struct OpenModelicaGeneratedFunctionCallbacks CoupledClutches_callback = {
   (int (*)(DATA *, void *)) CoupledClutches_performSimulation,
   (int (*)(DATA *, void *)) CoupledClutches_performQSSSimulation,
   CoupledClutches_callExternalObjectConstructors,
   CoupledClutches_callExternalObjectDestructors,
   CoupledClutches_initialNonLinearSystem,
   CoupledClutches_initialLinearSystem,
   CoupledClutches_initialMixedSystem,
   CoupledClutches_initializeStateSets,
   CoupledClutches_functionODE,
   CoupledClutches_functionAlgebraics,
   CoupledClutches_functionDAE,
   CoupledClutches_input_function,
   CoupledClutches_input_function_init,
   CoupledClutches_output_function,
   CoupledClutches_function_storeDelayed,
   CoupledClutches_updateBoundVariableAttributes,
   1 /* useSymbolicInitialization */,
   0 /* useHomotopy */,
   CoupledClutches_functionInitialEquations,
   CoupledClutches_functionRemovedInitialEquations,
   CoupledClutches_updateBoundParameters,
   CoupledClutches_checkForAsserts,
   CoupledClutches_function_ZeroCrossingsEquations,
   CoupledClutches_function_ZeroCrossings,
   CoupledClutches_function_updateRelations,
   CoupledClutches_checkForDiscreteChanges,
   CoupledClutches_zeroCrossingDescription,
   CoupledClutches_relationDescription,
   CoupledClutches_function_initSample,
   CoupledClutches_INDEX_JAC_A,
   CoupledClutches_INDEX_JAC_B,
   CoupledClutches_INDEX_JAC_C,
   CoupledClutches_INDEX_JAC_D,
   CoupledClutches_initialAnalyticJacobianA,
   CoupledClutches_initialAnalyticJacobianB,
   CoupledClutches_initialAnalyticJacobianC,
   CoupledClutches_initialAnalyticJacobianD,
   CoupledClutches_functionJacA_column,
   CoupledClutches_functionJacB_column,
   CoupledClutches_functionJacC_column,
   CoupledClutches_functionJacD_column,
   CoupledClutches_linear_model_frame,
   CoupledClutches_mayer,
   CoupledClutches_lagrange,
   CoupledClutches_pickUpBoundsForInputsInOptimization,
   CoupledClutches_setInputData,
   CoupledClutches_getTimeGrid

};

void CoupledClutches_setupDataStruc(DATA *data)
{
  assertStreamPrint(threadData,0!=data, "Error while initialize Data");
  data->callback = &CoupledClutches_callback;
  data->modelData.modelName = "CoupledClutches";
  data->modelData.modelFilePrefix = "CoupledClutches";
  data->modelData.resultFileName = NULL;
  data->modelData.modelDir = "c:/OpenModelicaExternal/tools/FMI/Test_FMUs/FMI_1.0/ModelExchange/win32/OpenModelica/1.9.2/CoupledClutches";
  data->modelData.modelGUID = "{8c4e810f-3df3-4a00-8276-176fa3c9f9e0}";
  #ifdef OPENMODELICA_XML_FROM_FILE_AT_RUNTIME
  data->modelData.initXMLData = NULL;
  data->modelData.modelDataXml.infoXMLData = NULL;
  #else
  data->modelData.initXMLData =
  #include "CoupledClutches_init.c"
  ;
  data->modelData.modelDataXml.infoXMLData =
  #include "CoupledClutches_info.c"
  ;
  #endif
  
  data->modelData.nStates = 8;
  data->modelData.nVariablesReal = 2*8+40+0+0 + 0;
  data->modelData.nDiscreteReal = 0;
  data->modelData.nVariablesInteger = 3;
  data->modelData.nVariablesBoolean = 12;
  data->modelData.nVariablesString = 0;
  data->modelData.nParametersReal = 42;
  data->modelData.nParametersInteger = 7;
  data->modelData.nParametersBoolean = 4;
  data->modelData.nParametersString = 0;
  data->modelData.nInputVars = 1;
  data->modelData.nOutputVars = 4;
  
  data->modelData.nAliasReal = 53;
  data->modelData.nAliasInteger = 0;
  data->modelData.nAliasBoolean = 0;
  data->modelData.nAliasString = 0;
  
  data->modelData.nZeroCrossings = 18;
  data->modelData.nSamples = 0;
  data->modelData.nRelations = 30;
  data->modelData.nMathEvents = 0;
  data->modelData.nExtObjs = 0;
  setupModelInfoFunctions(1);
  data->modelData.modelDataXml.fileName = "CoupledClutches_info.json";
  data->modelData.modelDataXml.modelInfoXmlLength = 0;
  data->modelData.modelDataXml.nFunctions = 1;
  data->modelData.modelDataXml.nProfileBlocks = 0;
  data->modelData.modelDataXml.nEquations = 173;
  data->modelData.nMixedSystems = 0;
  data->modelData.nLinearSystems = 0;
  data->modelData.nNonLinearSystems = 2;
  data->modelData.nStateSets = 0;
  data->modelData.nJacobians = 4;
  data->modelData.nOptimizeConstraints = 0;
  data->modelData.nOptimizeFinalConstraints = 0;
  
  data->modelData.nDelayExpressions = 0;
  
}

#ifdef __cplusplus
}
#endif

static int rml_execution_failed()
{
  fflush(NULL);
  fprintf(stderr, "Execution failed!\n");
  fflush(NULL);
  return 1;
}

#if defined(threadData)
#undef threadData
#endif
/* call the simulation runtime main from our main! */
int main(int argc, char**argv)
{
  int res;
  DATA simulation_data;
  MMC_INIT();omc_alloc_interface.init();
  {
    MMC_TRY_TOP()
  
    MMC_TRY_STACK()
  
    CoupledClutches_setupDataStruc(&simulation_data);
    simulation_data.threadData = threadData;
    res = _main_SimulationRuntime(argc, argv, &simulation_data);
    
    MMC_ELSE()
    rml_execution_failed();
    fprintf(stderr, "Stack overflow detected and was not caught.\nSend us a bug report at https://trac.openmodelica.org/OpenModelica/newticket\n    Include the following trace:\n");
    printStacktraceMessages();
    fflush(NULL);
    return 1;
    MMC_CATCH_STACK()
    
    MMC_CATCH_TOP(return rml_execution_failed());
  }

  fflush(NULL);
  EXIT(res);
  return res;
}

