/* Initialization */
/* Simulation code for IntegerNetwork1 generated by the OpenModelica Compiler 1.9.2+dev (r24999). */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_xml.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <assert.h>
#include <string.h>

#include "IntegerNetwork1_functions.h"
#include "IntegerNetwork1_model.h"
#include "IntegerNetwork1_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif

#define threadData data->threadData

#include "IntegerNetwork1_11mix.h"
#include "IntegerNetwork1_12jac.h"
#if defined(__cplusplus)
extern "C" {
#endif


/*
 equation index: 1
 type: SIMPLE_ASSIGN
 $whenCondition4 = false
 */
void IntegerNetwork1_eqFunction_1(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,1};
  $P$whenCondition4 = 0;
  TRACE_POP
}
/*
 equation index: 2
 type: SIMPLE_ASSIGN
 $whenCondition3 = false
 */
void IntegerNetwork1_eqFunction_2(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,2};
  $P$whenCondition3 = 0;
  TRACE_POP
}
/*
 equation index: 3
 type: SIMPLE_ASSIGN
 $whenCondition1 = false
 */
void IntegerNetwork1_eqFunction_3(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,3};
  $P$whenCondition1 = 0;
  TRACE_POP
}
/*
 equation index: 4
 type: SIMPLE_ASSIGN
 $PRE._triggeredAdd._y = triggeredAdd.y_start
 */
void IntegerNetwork1_eqFunction_4(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,4};
  $P$PRE$PtriggeredAdd$Py = (modelica_integer)$PtriggeredAdd$Py_start;
  TRACE_POP
}
/*
 equation index: 5
 type: SIMPLE_ASSIGN
 triggeredAdd._y = $PRE.triggeredAdd.y
 */
void IntegerNetwork1_eqFunction_5(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,5};
  $PtriggeredAdd$Py = $P$PRE$PtriggeredAdd$Py;
  TRACE_POP
}
/*
 equation index: 6
 type: SIMPLE_ASSIGN
 y4 = triggeredAdd.y
 */
void IntegerNetwork1_eqFunction_6(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,6};
  $Py4 = (modelica_integer)$PtriggeredAdd$Py;
  TRACE_POP
}
/*
 equation index: 7
 type: SIMPLE_ASSIGN
 y5 = sine.offset + (if time < sine.startTime then 0.0 else sine.amplitude * sin(6.283185307179586 * sine.freqHz * (time - sine.startTime) + sine.phase))
 */
void IntegerNetwork1_eqFunction_7(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7};
  modelica_boolean tmp0;
  RELATIONHYSTERESIS(tmp0, time, $Psine$PstartTime, 0, Less);
  $Py5 = ($Psine$Poffset + (tmp0?0.0:($Psine$Pamplitude * sin(((6.283185307179586 * ($Psine$PfreqHz * (time - $Psine$PstartTime))) + $Psine$Pphase)))));
  TRACE_POP
}
/*
 equation index: 8
 type: SIMPLE_ASSIGN
 y2 = if y5 > 0.0 then integer(floor(0.5 + y5, 1), 0) else integer(ceil(y5 + -0.5, 3), 2)
 */
void IntegerNetwork1_eqFunction_8(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,8};
  modelica_boolean tmp1;
  RELATIONHYSTERESIS(tmp1, $Py5, 0.0, 1, Greater);
  $Py2 = (tmp1?(_event_integer(((modelica_real)_event_floor((0.5 + $Py5), (modelica_integer) 1, data)), (modelica_integer) 0, data)):(_event_integer(((modelica_real)_event_ceil(($Py5 + -0.5), (modelica_integer) 3, data)), (modelica_integer) 2, data)));
  TRACE_POP
}
/*
 equation index: 9
 type: SIMPLE_ASSIGN
 y3 = sum.k[1] * y2 + sum.k[2] * integerStep + sum.k[3] * integerConstant.k
 */
void IntegerNetwork1_eqFunction_9(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,9};
  $Py3 = (((modelica_integer)$Psum$Pk$lB1$rB * (modelica_integer)$Py2) + (((modelica_integer)$Psum$Pk$lB2$rB * (modelica_integer)$PintegerStep) + ((modelica_integer)$Psum$Pk$lB3$rB * (modelica_integer)$PintegerConstant$Pk)));
  TRACE_POP
}
/*
 equation index: 10
 type: SIMPLE_ASSIGN
 y1 = y3 * integerStep
 */
void IntegerNetwork1_eqFunction_10(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,10};
  $Py1 = ((modelica_integer)$Py3 * (modelica_integer)$PintegerStep);
  TRACE_POP
}
/*
 equation index: 11
 type: SIMPLE_ASSIGN
 showValue._number = 0
 */
void IntegerNetwork1_eqFunction_11(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,11};
  $PshowValue$Pnumber = (modelica_integer) 0;
  TRACE_POP
}
/*
 equation index: 12
 type: SIMPLE_ASSIGN
 showValue1._number = 0
 */
void IntegerNetwork1_eqFunction_12(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,12};
  $PshowValue1$Pnumber = (modelica_integer) 0;
  TRACE_POP
}
/*
 equation index: 13
 type: SIMPLE_ASSIGN
 showValue2._number = 0
 */
void IntegerNetwork1_eqFunction_13(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,13};
  $PshowValue2$Pnumber = (modelica_integer) 0;
  TRACE_POP
}
/*
 equation index: 14
 type: SIMPLE_ASSIGN
 triggeredAdd._local_reset = false
 */
void IntegerNetwork1_eqFunction_14(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,14};
  $PtriggeredAdd$Plocal_reset = 0;
  TRACE_POP
}
/*
 equation index: 15
 type: SIMPLE_ASSIGN
 triggeredAdd._local_set = 0
 */
void IntegerNetwork1_eqFunction_15(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,15};
  $PtriggeredAdd$Plocal_set = (modelica_integer) 0;
  TRACE_POP
}
/*
 equation index: 16
 type: SIMPLE_ASSIGN
 multiSwitch1._expr[2] = 6
 */
void IntegerNetwork1_eqFunction_16(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,16};
  $PmultiSwitch1$Pexpr$lB2$rB = (modelica_integer) 6;
  TRACE_POP
}
/*
 equation index: 17
 type: SIMPLE_ASSIGN
 multiSwitch1._expr[1] = 4
 */
void IntegerNetwork1_eqFunction_17(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,17};
  $PmultiSwitch1$Pexpr$lB1$rB = (modelica_integer) 4;
  TRACE_POP
}
/*
 equation index: 18
 type: SIMPLE_ASSIGN
 booleanPulse2._pulsStart = booleanPulse2.startTime
 */
void IntegerNetwork1_eqFunction_18(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,18};
  $PbooleanPulse2$PpulsStart = $PbooleanPulse2$PstartTime;
  TRACE_POP
}
/*
 equation index: 19
 type: SIMPLE_ASSIGN
 multiSwitch1._u[2] = time >= booleanPulse2.pulsStart and time < booleanPulse2.pulsStart + 1.6
 */
void IntegerNetwork1_eqFunction_19(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,19};
  modelica_boolean tmp2;
  modelica_boolean tmp3;
  RELATIONHYSTERESIS(tmp2, time, $PbooleanPulse2$PpulsStart, 4, GreaterEq);
  RELATIONHYSTERESIS(tmp3, time, ($PbooleanPulse2$PpulsStart + 1.6), 5, Less);
  $PmultiSwitch1$Pu$lB2$rB = (tmp2 && tmp3);
  TRACE_POP
}
/*
 equation index: 20
 type: SIMPLE_ASSIGN
 $PRE._booleanPulse2._pulsStart = booleanPulse2.pulsStart
 */
void IntegerNetwork1_eqFunction_20(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,20};
  $P$PRE$PbooleanPulse2$PpulsStart = $PbooleanPulse2$PpulsStart;
  TRACE_POP
}
/*
 equation index: 21
 type: SIMPLE_ASSIGN
 $PRE._multiSwitch1._y = multiSwitch1.y_default
 */
void IntegerNetwork1_eqFunction_21(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,21};
  $P$PRE$PmultiSwitch1$Py = (modelica_integer)$PmultiSwitch1$Py_default;
  TRACE_POP
}
/*
 equation index: 22
 type: SIMPLE_ASSIGN
 booleanPulse1._pulsStart = booleanPulse1.startTime
 */
void IntegerNetwork1_eqFunction_22(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,22};
  $PbooleanPulse1$PpulsStart = $PbooleanPulse1$PstartTime;
  TRACE_POP
}
/*
 equation index: 23
 type: SIMPLE_ASSIGN
 multiSwitch1._u[1] = time >= booleanPulse1.pulsStart and time < booleanPulse1.pulsStart + 0.5
 */
void IntegerNetwork1_eqFunction_23(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,23};
  modelica_boolean tmp4;
  modelica_boolean tmp5;
  RELATIONHYSTERESIS(tmp4, time, $PbooleanPulse1$PpulsStart, 2, GreaterEq);
  RELATIONHYSTERESIS(tmp5, time, ($PbooleanPulse1$PpulsStart + 0.5), 3, Less);
  $PmultiSwitch1$Pu$lB1$rB = (tmp4 && tmp5);
  TRACE_POP
}
/*
 equation index: 24
 type: SIMPLE_ASSIGN
 $whenCondition2 = multiSwitch1.u[1]
 */
void IntegerNetwork1_eqFunction_24(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,24};
  $P$whenCondition2 = $PmultiSwitch1$Pu$lB1$rB;
  TRACE_POP
}
/*
 equation index: 25
 type: SIMPLE_ASSIGN
 multiSwitch1._firstActiveIndex = Modelica.Math.BooleanVectors.firstTrueIndex({multiSwitch1.u[1], multiSwitch1.u[2]})
 */
void IntegerNetwork1_eqFunction_25(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,25};
  boolean_array tmp6;
  array_alloc_scalar_boolean_array(&tmp6, 2, (modelica_boolean)$PmultiSwitch1$Pu$lB1$rB, (modelica_boolean)$PmultiSwitch1$Pu$lB2$rB);
  $PmultiSwitch1$PfirstActiveIndex = omc_Modelica_Math_BooleanVectors_firstTrueIndex(threadData, tmp6);
  TRACE_POP
}
/*
 equation index: 26
 type: SIMPLE_ASSIGN
 multiSwitch1._y = if multiSwitch1.firstActiveIndex > 0 then multiSwitch1.expr[multiSwitch1.firstActiveIndex] else if multiSwitch1.use_pre_as_default then $PRE.multiSwitch1.y else multiSwitch1.y_default
 */
void IntegerNetwork1_eqFunction_26(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,26};
  modelica_boolean tmp7;
  tmp7 = Greater((modelica_integer)$PmultiSwitch1$PfirstActiveIndex,(modelica_integer) 0);
  $PmultiSwitch1$Py = (tmp7?(modelica_integer)$PmultiSwitch1$Pexpr_index((modelica_integer)$PmultiSwitch1$PfirstActiveIndex):($PmultiSwitch1$Puse_pre_as_default?(modelica_integer)$P$PRE$PmultiSwitch1$Py:(modelica_integer)$PmultiSwitch1$Py_default));
  TRACE_POP
}
/*
 equation index: 27
 type: SIMPLE_ASSIGN
 y = multiSwitch1.y
 */
void IntegerNetwork1_eqFunction_27(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,27};
  $Py = (modelica_integer)$PmultiSwitch1$Py;
  TRACE_POP
}
/*
 equation index: 28
 type: SIMPLE_ASSIGN
 $PRE._booleanPulse1._pulsStart = booleanPulse1.pulsStart
 */
void IntegerNetwork1_eqFunction_28(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,28};
  $P$PRE$PbooleanPulse1$PpulsStart = $PbooleanPulse1$PpulsStart;
  TRACE_POP
}


int IntegerNetwork1_functionInitialEquations(DATA *data)
{
  TRACE_PUSH

  data->simulationInfo.discreteCall = 1;
  IntegerNetwork1_eqFunction_1(data);

  IntegerNetwork1_eqFunction_2(data);

  IntegerNetwork1_eqFunction_3(data);

  IntegerNetwork1_eqFunction_4(data);

  IntegerNetwork1_eqFunction_5(data);

  IntegerNetwork1_eqFunction_6(data);

  IntegerNetwork1_eqFunction_7(data);

  IntegerNetwork1_eqFunction_8(data);

  IntegerNetwork1_eqFunction_9(data);

  IntegerNetwork1_eqFunction_10(data);

  IntegerNetwork1_eqFunction_11(data);

  IntegerNetwork1_eqFunction_12(data);

  IntegerNetwork1_eqFunction_13(data);

  IntegerNetwork1_eqFunction_14(data);

  IntegerNetwork1_eqFunction_15(data);

  IntegerNetwork1_eqFunction_16(data);

  IntegerNetwork1_eqFunction_17(data);

  IntegerNetwork1_eqFunction_18(data);

  IntegerNetwork1_eqFunction_19(data);

  IntegerNetwork1_eqFunction_20(data);

  IntegerNetwork1_eqFunction_21(data);

  IntegerNetwork1_eqFunction_22(data);

  IntegerNetwork1_eqFunction_23(data);

  IntegerNetwork1_eqFunction_24(data);

  IntegerNetwork1_eqFunction_25(data);

  IntegerNetwork1_eqFunction_26(data);

  IntegerNetwork1_eqFunction_27(data);

  IntegerNetwork1_eqFunction_28(data);
  data->simulationInfo.discreteCall = 0;
  
  TRACE_POP
  return 0;
}
int IntegerNetwork1_functionRemovedInitialEquations(DATA *data)
{
  TRACE_PUSH
  const int *equationIndexes = NULL;
  double res = 0.0;

  
  TRACE_POP
  return 0;
}

/* funtion initialize mixed systems */
void IntegerNetwork1_initialMixedSystem(int nMixedSystems, MIXED_SYSTEM_DATA* mixedSystemData)
{
  /* initial mixed systems */
  /* parameter mixed systems */
  /* model mixed systems */
  /* jacobians mixed systems */
}

#if defined(__cplusplus)
}
#endif

