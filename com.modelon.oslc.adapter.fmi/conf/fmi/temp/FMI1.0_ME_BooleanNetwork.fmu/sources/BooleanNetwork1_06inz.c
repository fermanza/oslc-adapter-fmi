/* Initialization */
/* Simulation code for BooleanNetwork1 generated by the OpenModelica Compiler 1.9.2+dev (r24999). */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_xml.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <assert.h>
#include <string.h>

#include "BooleanNetwork1_functions.h"
#include "BooleanNetwork1_model.h"
#include "BooleanNetwork1_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif

#define threadData data->threadData

#include "BooleanNetwork1_11mix.h"
#include "BooleanNetwork1_12jac.h"
#if defined(__cplusplus)
extern "C" {
#endif


/*
 equation index: 1
 type: SIMPLE_ASSIGN
 $PRE._onDelay._u = false
 */
void BooleanNetwork1_eqFunction_1(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,1};
  $P$PRE$PonDelay$Pu = 0;
  TRACE_POP
}
/*
 equation index: 2
 type: SIMPLE_ASSIGN
 $PRE._onDelay._t_next = -1.0 + time
 */
void BooleanNetwork1_eqFunction_2(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,2};
  $P$PRE$PonDelay$Pt_next = (-1.0 + time);
  TRACE_POP
}
/*
 equation index: 3
 type: ALGORITHM
 
   (booleanTable.index, booleanTable.nextTime, booleanTable.y) := Modelica.Blocks.Sources.BooleanTable$booleanTable.getFirstIndex(booleanTable.table, time, booleanTable.startValue);
 */
void BooleanNetwork1_eqFunction_3(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,3};
  real_array tmp0;
  /* tuple assignment booleanTable.index, booleanTable.nextTime, booleanTable.y*/
  real_array_create(&tmp0, ((modelica_real*)&($PbooleanTable$Ptable_index((modelica_integer) 1))), 1, 7);
  $PbooleanTable$Pindex = omc_Modelica_Blocks_Sources_BooleanTable$booleanTable_getFirstIndex(threadData, tmp0, time, $PbooleanTable$PstartValue, &$PbooleanTable$PnextTime, &$PbooleanTable$Py);
  TRACE_POP
}
/*
 equation index: 4
 type: SIMPLE_ASSIGN
 $PRE._booleanTable._index = booleanTable.index
 */
void BooleanNetwork1_eqFunction_4(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,4};
  $P$PRE$PbooleanTable$Pindex = (modelica_integer)$PbooleanTable$Pindex;
  TRACE_POP
}
/*
 equation index: 5
 type: SIMPLE_ASSIGN
 $PRE._booleanTable._nextTime = booleanTable.nextTime
 */
void BooleanNetwork1_eqFunction_5(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,5};
  $P$PRE$PbooleanTable$PnextTime = $PbooleanTable$PnextTime;
  TRACE_POP
}
/*
 equation index: 6
 type: ALGORITHM
 
   $whenCondition1 := time >= $PRE.booleanTable.nextTime;
 */
void BooleanNetwork1_eqFunction_6(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,6};
  modelica_boolean tmp1;
  RELATIONHYSTERESIS(tmp1, time, $P$PRE$PbooleanTable$PnextTime, 0, GreaterEq);
  $P$whenCondition1 = tmp1;
  TRACE_POP
}
/*
 equation index: 7
 type: SIMPLE_ASSIGN
 onDelay._u = booleanTable.y
 */
void BooleanNetwork1_eqFunction_7(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,7};
  $PonDelay$Pu = $PbooleanTable$Py;
  TRACE_POP
}
/*
 equation index: 8
 type: ALGORITHM
 
   $whenCondition2 := onDelay.u;
   $whenCondition3 := not onDelay.u;
   onDelay.delaySignal := onDelay.u;
   onDelay.t_next := -1.0 + time;
 */
void BooleanNetwork1_eqFunction_8(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,8};
  $P$whenCondition2 = $PonDelay$Pu;

  $P$whenCondition3 = (!$PonDelay$Pu);

  $PonDelay$PdelaySignal = $PonDelay$Pu;

  $PonDelay$Pt_next = (-1.0 + time);
  TRACE_POP
}
/*
 equation index: 9
 type: SIMPLE_ASSIGN
 y4 = if onDelay.delaySignal then time >= onDelay.t_next else false
 */
void BooleanNetwork1_eqFunction_9(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,9};
  modelica_boolean tmp2;
  modelica_boolean tmp3;
  modelica_boolean tmp4;
  tmp3 = (modelica_boolean)$PonDelay$PdelaySignal;
  if(tmp3)
  {
    RELATIONHYSTERESIS(tmp2, time, $PonDelay$Pt_next, 1, GreaterEq);
    tmp4 = tmp2;
  }
  else
  {
    tmp4 = 0;
  }
  $Py4 = tmp4;
  TRACE_POP
}
/*
 equation index: 10
 type: SIMPLE_ASSIGN
 $PRE._booleanTable._y = booleanTable.y
 */
void BooleanNetwork1_eqFunction_10(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,10};
  $P$PRE$PbooleanTable$Py = $PbooleanTable$Py;
  TRACE_POP
}
/*
 equation index: 11
 type: SIMPLE_ASSIGN
 $whenCondition7 = false
 */
void BooleanNetwork1_eqFunction_11(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,11};
  $P$whenCondition7 = 0;
  TRACE_POP
}
/*
 equation index: 12
 type: SIMPLE_ASSIGN
 $whenCondition5 = false
 */
void BooleanNetwork1_eqFunction_12(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,12};
  $P$whenCondition5 = 0;
  TRACE_POP
}
/*
 equation index: 13
 type: SIMPLE_ASSIGN
 $whenCondition4 = false
 */
void BooleanNetwork1_eqFunction_13(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,13};
  $P$whenCondition4 = 0;
  TRACE_POP
}
/*
 equation index: 14
 type: SIMPLE_ASSIGN
 $PRE._triggeredAdd._y = triggeredAdd.y_start
 */
void BooleanNetwork1_eqFunction_14(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,14};
  $P$PRE$PtriggeredAdd$Py = (modelica_integer)$PtriggeredAdd$Py_start;
  TRACE_POP
}
/*
 equation index: 15
 type: SIMPLE_ASSIGN
 triggeredAdd._y = $PRE.triggeredAdd.y
 */
void BooleanNetwork1_eqFunction_15(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,15};
  $PtriggeredAdd$Py = $P$PRE$PtriggeredAdd$Py;
  TRACE_POP
}
/*
 equation index: 16
 type: SIMPLE_ASSIGN
 y1 = triggeredAdd.y
 */
void BooleanNetwork1_eqFunction_16(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,16};
  $Py1 = (modelica_integer)$PtriggeredAdd$Py;
  TRACE_POP
}
/*
 equation index: 17
 type: SIMPLE_ASSIGN
 showValue._active = false
 */
void BooleanNetwork1_eqFunction_17(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,17};
  $PshowValue$Pactive = 0;
  TRACE_POP
}
/*
 equation index: 18
 type: SIMPLE_ASSIGN
 showValue2._active = false
 */
void BooleanNetwork1_eqFunction_18(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,18};
  $PshowValue2$Pactive = 0;
  TRACE_POP
}
/*
 equation index: 19
 type: SIMPLE_ASSIGN
 showValue3._active = false
 */
void BooleanNetwork1_eqFunction_19(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,19};
  $PshowValue3$Pactive = 0;
  TRACE_POP
}
/*
 equation index: 20
 type: SIMPLE_ASSIGN
 showValue4._active = false
 */
void BooleanNetwork1_eqFunction_20(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,20};
  $PshowValue4$Pactive = 0;
  TRACE_POP
}
/*
 equation index: 21
 type: SIMPLE_ASSIGN
 showValue1._number = 0
 */
void BooleanNetwork1_eqFunction_21(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,21};
  $PshowValue1$Pnumber = (modelica_integer) 0;
  TRACE_POP
}
/*
 equation index: 22
 type: SIMPLE_ASSIGN
 showValue5._active = false
 */
void BooleanNetwork1_eqFunction_22(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,22};
  $PshowValue5$Pactive = 0;
  TRACE_POP
}
/*
 equation index: 23
 type: SIMPLE_ASSIGN
 showValue6._active = false
 */
void BooleanNetwork1_eqFunction_23(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,23};
  $PshowValue6$Pactive = 0;
  TRACE_POP
}
/*
 equation index: 24
 type: SIMPLE_ASSIGN
 set1._expr[2] = true
 */
void BooleanNetwork1_eqFunction_24(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,24};
  $Pset1$Pexpr$lB2$rB = 1;
  TRACE_POP
}
/*
 equation index: 25
 type: SIMPLE_ASSIGN
 set1._expr[1] = false
 */
void BooleanNetwork1_eqFunction_25(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,25};
  $Pset1$Pexpr$lB1$rB = 0;
  TRACE_POP
}
/*
 equation index: 26
 type: SIMPLE_ASSIGN
 $PRE._changing._u = changing.pre_u_start
 */
void BooleanNetwork1_eqFunction_26(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,26};
  $P$PRE$Pchanging$Pu = $Pchanging$Ppre_u_start;
  TRACE_POP
}
/*
 equation index: 27
 type: SIMPLE_ASSIGN
 $PRE._falling._not_u = not falling.pre_u_start
 */
void BooleanNetwork1_eqFunction_27(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,27};
  $P$PRE$Pfalling$Pnot_u = (!$Pfalling$Ppre_u_start);
  TRACE_POP
}
/*
 equation index: 28
 type: SIMPLE_ASSIGN
 $PRE._set1._y = set1.y_default
 */
void BooleanNetwork1_eqFunction_28(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,28};
  $P$PRE$Pset1$Py = $Pset1$Py_default;
  TRACE_POP
}
/*
 equation index: 29
 type: SIMPLE_ASSIGN
 $PRE._rising._u = rising.pre_u_start
 */
void BooleanNetwork1_eqFunction_29(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,29};
  $P$PRE$Prising$Pu = $Prising$Ppre_u_start;
  TRACE_POP
}
/*
 equation index: 30
 type: SIMPLE_ASSIGN
 booleanPulse2._pulsStart = booleanPulse2.startTime
 */
void BooleanNetwork1_eqFunction_30(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,30};
  $PbooleanPulse2$PpulsStart = $PbooleanPulse2$PstartTime;
  TRACE_POP
}
/*
 equation index: 31
 type: SIMPLE_ASSIGN
 rising._u = time >= booleanPulse2.pulsStart and time < booleanPulse2.pulsStart + 0.8
 */
void BooleanNetwork1_eqFunction_31(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,31};
  modelica_boolean tmp5;
  modelica_boolean tmp6;
  RELATIONHYSTERESIS(tmp5, time, $PbooleanPulse2$PpulsStart, 4, GreaterEq);
  RELATIONHYSTERESIS(tmp6, time, ($PbooleanPulse2$PpulsStart + 0.8), 5, Less);
  $Prising$Pu = (tmp5 && tmp6);
  TRACE_POP
}
/*
 equation index: 32
 type: SIMPLE_ASSIGN
 set1._u[1] = rising.u and not $PRE.rising.u
 */
void BooleanNetwork1_eqFunction_32(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,32};
  $Pset1$Pu$lB1$rB = ($Prising$Pu && (!$P$PRE$Prising$Pu));
  TRACE_POP
}
/*
 equation index: 33
 type: SIMPLE_ASSIGN
 falling._not_u = not rising.u
 */
void BooleanNetwork1_eqFunction_33(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,33};
  $Pfalling$Pnot_u = (!$Prising$Pu);
  TRACE_POP
}
/*
 equation index: 34
 type: SIMPLE_ASSIGN
 set1._u[2] = falling.not_u and not $PRE.falling.not_u
 */
void BooleanNetwork1_eqFunction_34(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,34};
  $Pset1$Pu$lB2$rB = ($Pfalling$Pnot_u && (!$P$PRE$Pfalling$Pnot_u));
  TRACE_POP
}
/*
 equation index: 35
 type: SIMPLE_ASSIGN
 set1._firstActiveIndex = Modelica.Math.BooleanVectors.firstTrueIndex({set1.u[1], set1.u[2]})
 */
void BooleanNetwork1_eqFunction_35(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,35};
  boolean_array tmp7;
  array_alloc_scalar_boolean_array(&tmp7, 2, (modelica_boolean)$Pset1$Pu$lB1$rB, (modelica_boolean)$Pset1$Pu$lB2$rB);
  $Pset1$PfirstActiveIndex = omc_Modelica_Math_BooleanVectors_firstTrueIndex(threadData, tmp7);
  TRACE_POP
}
/*
 equation index: 36
 type: SIMPLE_ASSIGN
 set1._y = if set1.firstActiveIndex == 0 then if set1.use_pre_as_default then $PRE.set1.y else set1.y_default else set1.expr[set1.firstActiveIndex]
 */
void BooleanNetwork1_eqFunction_36(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,36};
  $Pset1$Py = (((modelica_integer)$Pset1$PfirstActiveIndex == (modelica_integer) 0)?($Pset1$Puse_pre_as_default?$P$PRE$Pset1$Py:$Pset1$Py_default):$Pset1$Pexpr_index((modelica_integer)$Pset1$PfirstActiveIndex));
  TRACE_POP
}
/*
 equation index: 37
 type: SIMPLE_ASSIGN
 y3 = set1.y
 */
void BooleanNetwork1_eqFunction_37(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,37};
  $Py3 = $Pset1$Py;
  TRACE_POP
}
/*
 equation index: 38
 type: SIMPLE_ASSIGN
 y2 = not falling.not_u
 */
void BooleanNetwork1_eqFunction_38(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,38};
  $Py2 = (!$Pfalling$Pnot_u);
  TRACE_POP
}
/*
 equation index: 39
 type: SIMPLE_ASSIGN
 changing._u = not falling.not_u
 */
void BooleanNetwork1_eqFunction_39(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,39};
  $Pchanging$Pu = (!$Pfalling$Pnot_u);
  TRACE_POP
}
/*
 equation index: 40
 type: SIMPLE_ASSIGN
 changing._y = changing.u <> $PRE.changing.u
 */
void BooleanNetwork1_eqFunction_40(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,40};
  $Pchanging$Py = ((!$Pchanging$Pu && $P$PRE$Pchanging$Pu) || ($Pchanging$Pu && !$P$PRE$Pchanging$Pu));
  TRACE_POP
}
/*
 equation index: 41
 type: SIMPLE_ASSIGN
 $whenCondition6 = changing.y
 */
void BooleanNetwork1_eqFunction_41(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,41};
  $P$whenCondition6 = $Pchanging$Py;
  TRACE_POP
}
/*
 equation index: 42
 type: SIMPLE_ASSIGN
 $PRE._booleanPulse2._pulsStart = booleanPulse2.pulsStart
 */
void BooleanNetwork1_eqFunction_42(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,42};
  $P$PRE$PbooleanPulse2$PpulsStart = $PbooleanPulse2$PpulsStart;
  TRACE_POP
}
/*
 equation index: 43
 type: SIMPLE_ASSIGN
 booleanPulse1._pulsStart = booleanPulse1.startTime
 */
void BooleanNetwork1_eqFunction_43(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,43};
  $PbooleanPulse1$PpulsStart = $PbooleanPulse1$PstartTime;
  TRACE_POP
}
/*
 equation index: 44
 type: SIMPLE_ASSIGN
 and1._u[1] = time >= booleanPulse1.pulsStart and time < booleanPulse1.pulsStart + 0.2
 */
void BooleanNetwork1_eqFunction_44(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,44};
  modelica_boolean tmp10;
  modelica_boolean tmp11;
  RELATIONHYSTERESIS(tmp10, time, $PbooleanPulse1$PpulsStart, 2, GreaterEq);
  RELATIONHYSTERESIS(tmp11, time, ($PbooleanPulse1$PpulsStart + 0.2), 3, Less);
  $Pand1$Pu$lB1$rB = (tmp10 && tmp11);
  TRACE_POP
}
/*
 equation index: 45
 type: SIMPLE_ASSIGN
 y = Modelica.Math.BooleanVectors.allTrue({and1.u[1], booleanStep, rising.u})
 */
void BooleanNetwork1_eqFunction_45(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,45};
  boolean_array tmp12;
  array_alloc_scalar_boolean_array(&tmp12, 3, (modelica_boolean)$Pand1$Pu$lB1$rB, (modelica_boolean)$PbooleanStep, (modelica_boolean)$Prising$Pu);
  $Py = omc_Modelica_Math_BooleanVectors_allTrue(threadData, tmp12);
  TRACE_POP
}
/*
 equation index: 46
 type: SIMPLE_ASSIGN
 xor1._u[1] = Modelica.Math.BooleanVectors.anyTrue({y, rising.u})
 */
void BooleanNetwork1_eqFunction_46(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,46};
  boolean_array tmp13;
  array_alloc_scalar_boolean_array(&tmp13, 2, (modelica_boolean)$Py, (modelica_boolean)$Prising$Pu);
  $Pxor1$Pu$lB1$rB = omc_Modelica_Math_BooleanVectors_anyTrue(threadData, tmp13);
  TRACE_POP
}
/*
 equation index: 47
 type: SIMPLE_ASSIGN
 nand1._u[1] = Modelica.Math.BooleanVectors.oneTrue({xor1.u[1], rising.u})
 */
void BooleanNetwork1_eqFunction_47(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,47};
  boolean_array tmp14;
  array_alloc_scalar_boolean_array(&tmp14, 2, (modelica_boolean)$Pxor1$Pu$lB1$rB, (modelica_boolean)$Prising$Pu);
  $Pnand1$Pu$lB1$rB = omc_Modelica_Math_BooleanVectors_oneTrue(threadData, tmp14);
  TRACE_POP
}
/*
 equation index: 48
 type: SIMPLE_ASSIGN
 or2._u[1] = not Modelica.Math.BooleanVectors.allTrue({nand1.u[1], rising.u})
 */
void BooleanNetwork1_eqFunction_48(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,48};
  boolean_array tmp15;
  array_alloc_scalar_boolean_array(&tmp15, 2, (modelica_boolean)$Pnand1$Pu$lB1$rB, (modelica_boolean)$Prising$Pu);
  $Por2$Pu$lB1$rB = (!omc_Modelica_Math_BooleanVectors_allTrue(threadData, tmp15));
  TRACE_POP
}
/*
 equation index: 49
 type: SIMPLE_ASSIGN
 nor1._y = Modelica.Math.BooleanVectors.anyTrue({or2.u[1], rising.u})
 */
void BooleanNetwork1_eqFunction_49(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,49};
  boolean_array tmp16;
  array_alloc_scalar_boolean_array(&tmp16, 2, (modelica_boolean)$Por2$Pu$lB1$rB, (modelica_boolean)$Prising$Pu);
  $Pnor1$Py = omc_Modelica_Math_BooleanVectors_anyTrue(threadData, tmp16);
  TRACE_POP
}
/*
 equation index: 50
 type: SIMPLE_ASSIGN
 $PRE._booleanPulse1._pulsStart = booleanPulse1.pulsStart
 */
void BooleanNetwork1_eqFunction_50(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,50};
  $P$PRE$PbooleanPulse1$PpulsStart = $PbooleanPulse1$PpulsStart;
  TRACE_POP
}
/*
 equation index: 51
 type: SIMPLE_ASSIGN
 triggeredAdd._local_reset = false
 */
void BooleanNetwork1_eqFunction_51(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,51};
  $PtriggeredAdd$Plocal_reset = 0;
  TRACE_POP
}
/*
 equation index: 52
 type: SIMPLE_ASSIGN
 triggeredAdd._local_set = 0
 */
void BooleanNetwork1_eqFunction_52(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,52};
  $PtriggeredAdd$Plocal_set = (modelica_integer) 0;
  TRACE_POP
}
/*
 equation index: 53
 type: SIMPLE_ASSIGN
 rSFlipFlop._pre._pre_u_start = not rSFlipFlop.Qini
 */
void BooleanNetwork1_eqFunction_53(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,53};
  $PrSFlipFlop$Ppre$Ppre_u_start = (!$PrSFlipFlop$PQini);
  TRACE_POP
}
/*
 equation index: 54
 type: SIMPLE_ASSIGN
 rSFlipFlop._R = false
 */
void BooleanNetwork1_eqFunction_54(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,54};
  $PrSFlipFlop$PR = 0;
  TRACE_POP
}
/*
 equation index: 55
 type: SIMPLE_ASSIGN
 rSFlipFlop._S = false
 */
void BooleanNetwork1_eqFunction_55(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,55};
  $PrSFlipFlop$PS = 0;
  TRACE_POP
}
/*
 equation index: 56
 type: SIMPLE_ASSIGN
 $PRE._rSFlipFlop._pre._u = rSFlipFlop.pre.pre_u_start
 */
void BooleanNetwork1_eqFunction_56(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,56};
  $P$PRE$PrSFlipFlop$Ppre$Pu = $PrSFlipFlop$Ppre$Ppre_u_start;
  TRACE_POP
}
/*
 equation index: 57
 type: SIMPLE_ASSIGN
 QI = $PRE.rSFlipFlop.pre.u
 */
void BooleanNetwork1_eqFunction_57(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,57};
  $PQI = $P$PRE$PrSFlipFlop$Ppre$Pu;
  TRACE_POP
}
/*
 equation index: 58
 type: SIMPLE_ASSIGN
 Q = not (QI or rSFlipFlop.R)
 */
void BooleanNetwork1_eqFunction_58(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,58};
  $PQ = (!($PQI || $PrSFlipFlop$PR));
  TRACE_POP
}
/*
 equation index: 59
 type: SIMPLE_ASSIGN
 rSFlipFlop._pre._u = not (rSFlipFlop.S or Q)
 */
void BooleanNetwork1_eqFunction_59(DATA *data)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,59};
  $PrSFlipFlop$Ppre$Pu = (!($PrSFlipFlop$PS || $PQ));
  TRACE_POP
}


int BooleanNetwork1_functionInitialEquations(DATA *data)
{
  TRACE_PUSH

  data->simulationInfo.discreteCall = 1;
  BooleanNetwork1_eqFunction_1(data);

  BooleanNetwork1_eqFunction_2(data);

  BooleanNetwork1_eqFunction_3(data);

  BooleanNetwork1_eqFunction_4(data);

  BooleanNetwork1_eqFunction_5(data);

  BooleanNetwork1_eqFunction_6(data);

  BooleanNetwork1_eqFunction_7(data);

  BooleanNetwork1_eqFunction_8(data);

  BooleanNetwork1_eqFunction_9(data);

  BooleanNetwork1_eqFunction_10(data);

  BooleanNetwork1_eqFunction_11(data);

  BooleanNetwork1_eqFunction_12(data);

  BooleanNetwork1_eqFunction_13(data);

  BooleanNetwork1_eqFunction_14(data);

  BooleanNetwork1_eqFunction_15(data);

  BooleanNetwork1_eqFunction_16(data);

  BooleanNetwork1_eqFunction_17(data);

  BooleanNetwork1_eqFunction_18(data);

  BooleanNetwork1_eqFunction_19(data);

  BooleanNetwork1_eqFunction_20(data);

  BooleanNetwork1_eqFunction_21(data);

  BooleanNetwork1_eqFunction_22(data);

  BooleanNetwork1_eqFunction_23(data);

  BooleanNetwork1_eqFunction_24(data);

  BooleanNetwork1_eqFunction_25(data);

  BooleanNetwork1_eqFunction_26(data);

  BooleanNetwork1_eqFunction_27(data);

  BooleanNetwork1_eqFunction_28(data);

  BooleanNetwork1_eqFunction_29(data);

  BooleanNetwork1_eqFunction_30(data);

  BooleanNetwork1_eqFunction_31(data);

  BooleanNetwork1_eqFunction_32(data);

  BooleanNetwork1_eqFunction_33(data);

  BooleanNetwork1_eqFunction_34(data);

  BooleanNetwork1_eqFunction_35(data);

  BooleanNetwork1_eqFunction_36(data);

  BooleanNetwork1_eqFunction_37(data);

  BooleanNetwork1_eqFunction_38(data);

  BooleanNetwork1_eqFunction_39(data);

  BooleanNetwork1_eqFunction_40(data);

  BooleanNetwork1_eqFunction_41(data);

  BooleanNetwork1_eqFunction_42(data);

  BooleanNetwork1_eqFunction_43(data);

  BooleanNetwork1_eqFunction_44(data);

  BooleanNetwork1_eqFunction_45(data);

  BooleanNetwork1_eqFunction_46(data);

  BooleanNetwork1_eqFunction_47(data);

  BooleanNetwork1_eqFunction_48(data);

  BooleanNetwork1_eqFunction_49(data);

  BooleanNetwork1_eqFunction_50(data);

  BooleanNetwork1_eqFunction_51(data);

  BooleanNetwork1_eqFunction_52(data);

  BooleanNetwork1_eqFunction_53(data);

  BooleanNetwork1_eqFunction_54(data);

  BooleanNetwork1_eqFunction_55(data);

  BooleanNetwork1_eqFunction_56(data);

  BooleanNetwork1_eqFunction_57(data);

  BooleanNetwork1_eqFunction_58(data);

  BooleanNetwork1_eqFunction_59(data);
  data->simulationInfo.discreteCall = 0;
  
  TRACE_POP
  return 0;
}
int BooleanNetwork1_functionRemovedInitialEquations(DATA *data)
{
  TRACE_PUSH
  const int *equationIndexes = NULL;
  double res = 0.0;

  
  TRACE_POP
  return 0;
}

/* funtion initialize mixed systems */
void BooleanNetwork1_initialMixedSystem(int nMixedSystems, MIXED_SYSTEM_DATA* mixedSystemData)
{
  /* initial mixed systems */
  /* parameter mixed systems */
  /* model mixed systems */
  /* jacobians mixed systems */
}

#if defined(__cplusplus)
}
#endif

